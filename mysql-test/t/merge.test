#
# Test of MERGE TABLES
#

# Clean up resources used in this test case.
# MERGE tables require MyISAM tables
let $default=`select @@global.storage_engine`;
set global storage_engine=myisam;
set session storage_engine=myisam;

--disable_warnings
drop table if exists t1,t2,t3,t4,t5,t6;
drop database if exists mysqltest;
--enable_warnings

create table t1 (a int not null primary key auto_increment, message char(20));
create table t2 (a int not null primary key auto_increment, message char(20));
INSERT INTO t1 (message) VALUES ("Testing"),("table"),("t1");
INSERT INTO t2 (message) VALUES ("Testing"),("table"),("t2");
create table t3 (a int not null, b char(20), key(a)) engine=MERGE UNION=(t1,t2);
select * from t3;
select * from t3 order by a desc;
drop table t3;
insert into t1 select NULL,message from t2;
insert into t2 select NULL,message from t1;
insert into t1 select NULL,message from t2;
insert into t2 select NULL,message from t1;
insert into t1 select NULL,message from t2;
insert into t2 select NULL,message from t1;
insert into t1 select NULL,message from t2;
insert into t2 select NULL,message from t1;
insert into t1 select NULL,message from t2;
insert into t2 select NULL,message from t1;
insert into t1 select NULL,message from t2;
create table t3 (a int not null, b char(20), key(a)) engine=MERGE UNION=(test.t1,test.t2);
explain select * from t3 where a < 10;
explain select * from t3 where a > 10 and a < 20;
select * from t3 where a = 10;
select * from t3 where a < 10;
select * from t3 where a > 10 and a < 20;
explain select a from t3 order by a desc limit 10;
select a from t3 order by a desc limit 10;
select a from t3 order by a desc limit 300,10;
delete from t3 where a=3;
select * from t3 where a < 10;
delete from t3 where a >= 6 and a <= 8;
select * from t3 where a < 10;
update t3 set a=3 where a=9;
select * from t3 where a < 10;
update t3 set a=6 where a=7;
select * from t3 where a < 10;
show create table t3;

# The following should give errors
create table t4 (a int not null, b char(10), key(a)) engine=MERGE UNION=(t1,t2);
--error 1168
select * from t4;
--error 1168
alter table t4 add column c int;
flush tables;
--error 1168
select * from t4;

#
# Test tables in different databases
#
create database mysqltest;
create table mysqltest.t6 (a int not null primary key auto_increment, message char(20));
create table t5 (a int not null, b char(20), key(a)) engine=MERGE UNION=(test.t1,mysqltest.t6);
show create table t5;
alter table t5 engine=myisam;
drop table t5, mysqltest.t6;
drop database mysqltest;

# Because of windows, it's important that we drop the merge tables first!
drop table t4,t3,t1,t2;
  
create table t1 (c char(10)) engine=myisam;
create table t2 (c char(10)) engine=myisam;
create table t3 (c char(10)) union=(t1,t2) engine=merge;
insert into t1 (c) values ('test1');
insert into t1 (c) values ('test1');
insert into t1 (c) values ('test1');
insert into t2 (c) values ('test2');
insert into t2 (c) values ('test2');
insert into t2 (c) values ('test2');
select * from t3;
select * from t3;
delete from t3 where 1=1;
select * from t3;
select * from t1;
drop table t3,t2,t1;

#
# Test 2
#

CREATE TABLE t1 (incr int not null, othr int not null, primary key(incr));
CREATE TABLE t2 (incr int not null, othr int not null, primary key(incr));
CREATE TABLE t3 (incr int not null, othr int not null, primary key(incr))
ENGINE=MERGE UNION=(t1,t2);

SELECT * from t3;

INSERT INTO t1 VALUES ( 1,10),( 3,53),( 5,21),( 7,12),( 9,17);
INSERT INTO t2 VALUES ( 2,24),( 4,33),( 6,41),( 8,26),( 0,32);
INSERT INTO t1 VALUES (11,20),(13,43),(15,11),(17,22),(19,37);
INSERT INTO t2 VALUES (12,25),(14,31),(16,42),(18,27),(10,30);

SELECT * from t3 where incr in (1,2,3,4) order by othr;
alter table t3 UNION=(t1);
select count(*) from t3;
alter table t3 UNION=(t1,t2);
select count(*) from t3;
alter table t3 ENGINE=MYISAM;
select count(*) from t3;

# Test that ALTER TABLE rembers the old UNION

drop table t3;
CREATE TABLE t3 (incr int not null, othr int not null, primary key(incr))
ENGINE=MERGE UNION=(t1,t2);
show create table t3;
alter table t3 drop primary key;
show create table t3;

drop table t3,t2,t1;

#
# Test table without unions
#
create table t1 (a int not null, key(a)) engine=merge;
select * from t1;
drop table t1;

#
# Bug in flush tables combined with MERGE tables
#

create table t1 (a int not null, b int not null, key(a,b));
create table t2 (a int not null, b int not null, key(a,b));
create table t3 (a int not null, b int not null, key(a,b)) ENGINE=MERGE UNION=(t1,t2);
insert into t1 values (1,2),(2,1),(0,0),(4,4),(5,5),(6,6);
insert into t2 values (1,1),(2,2),(0,0),(4,4),(5,5),(6,6);
flush tables;
select * from t3 where a=1 order by b limit 2;
drop table t3,t1,t2;

#
# [phi] testing INSERT_METHOD stuff
#

# first testing of common stuff with new parameters
create table t1 (a int not null, b int not null auto_increment, primary key(a,b));
create table t2 (a int not null, b int not null auto_increment, primary key(a,b));
create table t3 (a int not null, b int not null, key(a,b)) UNION=(t1,t2) INSERT_METHOD=NO;
create table t4 (a int not null, b int not null, key(a,b)) ENGINE=MERGE UNION=(t1,t2) INSERT_METHOD=NO;
create table t5 (a int not null, b int not null auto_increment, primary key(a,b)) ENGINE=MERGE UNION=(t1,t2) INSERT_METHOD=FIRST;
create table t6 (a int not null, b int not null auto_increment, primary key(a,b)) ENGINE=MERGE UNION=(t1,t2) INSERT_METHOD=LAST;
show create table t3;
show create table t4;
show create table t5;
show create table t6;
insert into t1 values (1,NULL),(1,NULL),(1,NULL),(1,NULL);
insert into t2 values (2,NULL),(2,NULL),(2,NULL),(2,NULL);
select * from t3 order by b,a limit 3;
select * from t4 order by b,a limit 3;
select * from t5 order by b,a limit 3,3;
select * from t6 order by b,a limit 6,3;
# now testing inserts and where the data gets written
insert into t5 values (5,1),(5,2);
insert into t6 values (6,1),(6,2);
select * from t1 order by a,b;
select * from t2 order by a,b;
select * from t4 order by a,b;
# preperation for next test
insert into t3 values (3,1),(3,2),(3,3),(3,4);
select * from t3 order by a,b;
# now testing whether options are kept by alter table
alter table t4 UNION=(t1,t2,t3);
show create table t4;
select * from t4 order by a,b;
# testing switching off insert method and inserts again
alter table t4 INSERT_METHOD=FIRST;
show create table t4;
insert into t4 values (4,1),(4,2);
select * from t1 order by a,b;
select * from t2 order by a,b;
select * from t3 order by a,b;
select * from t4 order by a,b;
select * from t5 order by a,b;
# auto_increment
select 1;
insert into t5 values (1,NULL),(5,NULL);
insert into t6 values (2,NULL),(6,NULL);
select * from t1 order by a,b;
select * from t2 order by a,b;
select * from t5 order by a,b;
select * from t6 order by a,b;
insert into t1 values (99,NULL);
select * from t4 where a+0 > 90;
# bug#4008 - cannot determine a unique key that caused "dupl. key error"
--error ER_DUP_ENTRY
insert t5 values (1,1);
--error ER_DUP_ENTRY
insert t6 values (2,1);
insert t5 values (1,1) on duplicate key update b=b+10;
insert t6 values (2,1) on duplicate key update b=b+20;
select * from t5 where a < 3;
drop table t6, t5, t4, t3, t2, t1;

CREATE TABLE t1 (  a int(11) NOT NULL default '0',  b int(11) NOT NULL default '0',  PRIMARY KEY  (a,b)) ENGINE=MyISAM;
INSERT INTO t1 VALUES (1,1), (2,1);
CREATE TABLE t2 (  a int(11) NOT NULL default '0',  b int(11) NOT NULL default '0',  PRIMARY KEY  (a,b)) ENGINE=MyISAM;
INSERT INTO t2 VALUES (1,2), (2,2);
CREATE TABLE t3 (  a int(11) NOT NULL default '0',  b int(11) NOT NULL default '0',  KEY a (a,b)) ENGINE=MRG_MyISAM UNION=(t1,t2);
select max(b) from t3 where a = 2;
select max(b) from t1 where a = 2;
drop table t3,t1,t2;

#
# temporary merge tables
#
CREATE TABLE t1 (c1 INT NOT NULL);
CREATE TABLE t2 (c1 INT NOT NULL);
INSERT INTO t1 VALUES (1);
INSERT INTO t2 VALUES (2);
CREATE TEMPORARY TABLE t3 (c1 INT NOT NULL) ENGINE=MRG_MYISAM UNION=(t1,t2);
--error ER_WRONG_MRG_TABLE
SELECT * FROM t3;
CREATE TEMPORARY TABLE t4 (c1 INT NOT NULL);
CREATE TEMPORARY TABLE t5 (c1 INT NOT NULL);
INSERT INTO t4 VALUES (4);
INSERT INTO t5 VALUES (5);
CREATE TEMPORARY TABLE t6 (c1 INT NOT NULL) ENGINE=MRG_MYISAM UNION=(t4,t5);
SELECT * FROM t6;
DROP TABLE t6, t3, t1, t2, t4, t5;
#
# Bug#19627 - temporary merge table locking
# MERGE table and its children must match in temporary type.
# Forbid temporary merge on non-temporary children: shown above.
# Forbid non-temporary merge on temporary children:
create temporary table t1 (a int not null);
create temporary table t2 (a int not null);
insert into t1 values (1);
insert into t2 values (2);
create table t3 (a int not null) ENGINE=MERGE UNION=(t1,t2);
--error ER_WRONG_MRG_TABLE
select * from t3;
drop table t3, t2, t1;
# Forbid children mismatch in temporary:
create table t1 (a int not null);
create temporary table t2 (a int not null);
insert into t1 values (1);
insert into t2 values (2);
create table t3 (a int not null) ENGINE=MERGE UNION=(t1,t2);
--error ER_WRONG_MRG_TABLE
select * from t3;
drop table t3;
create temporary table t3 (a int not null) ENGINE=MERGE UNION=(t1,t2);
--error ER_WRONG_MRG_TABLE
select * from t3;
drop table t3, t2, t1;
--echo # CREATE...SELECT is not implemented for MERGE tables.
CREATE TEMPORARY TABLE t1 (c1 INT NOT NULL);
CREATE TEMPORARY TABLE t2 (c1 INT NOT NULL);
CREATE TABLE t3 (c1 INT NOT NULL);
INSERT INTO t3 VALUES (3), (33);
LOCK TABLES t3 READ;
--error ER_WRONG_OBJECT
CREATE TEMPORARY TABLE t4 (c1 INT NOT NULL) ENGINE=MERGE UNION=(t1,t2)
  INSERT_METHOD=LAST SELECT * FROM t3;
--error ER_TABLE_NOT_LOCKED
SELECT * FROM t4;
UNLOCK TABLES;
CREATE TEMPORARY TABLE t4 (c1 INT NOT NULL) ENGINE=MERGE UNION=(t1,t2)
  INSERT_METHOD=LAST;
INSERT INTO t4 SELECT * FROM t3;
--echo # Alter temporary MERGE table.
ALTER TABLE t4 UNION=(t1);
LOCK TABLES t4 WRITE;
--echo # Alter temporary MERGE table under LOCk tables.
ALTER TABLE t4 UNION=(t1,t2);
UNLOCK TABLES;
--echo # MERGE table and function.
CREATE FUNCTION f1 () RETURNS INT RETURN (SELECT max(c1) FROM t3);
SELECT * FROM t4 WHERE c1 < f1();
DROP FUNCTION f1;
DROP TABLE t4, t3, t2, t1;

#
# testing merge::records_in_range and optimizer
#

CREATE TABLE t1 (
  fileset_id tinyint(3) unsigned NOT NULL default '0',
  file_code varchar(32) NOT NULL default '',
  fileset_root_id tinyint(3) unsigned NOT NULL default '0',
  PRIMARY KEY  (fileset_id,file_code),
  KEY files (fileset_id,fileset_root_id)
) ENGINE=MyISAM;
INSERT INTO t1 VALUES (2, '0000000111', 1), (2, '0000000112', 1), (2, '0000000113', 1),
(2, '0000000114', 1), (2, '0000000115', 1), (2, '0000000116', 1), (2, '0000000117', 1),
(2, '0000000118', 1), (2, '0000000119', 1), (2, '0000000120', 1);
CREATE TABLE t2 (
  fileset_id tinyint(3) unsigned NOT NULL default '0',
  file_code varchar(32) NOT NULL default '',
  fileset_root_id tinyint(3) unsigned NOT NULL default '0',
  PRIMARY KEY  (fileset_id,file_code),
  KEY files (fileset_id,fileset_root_id)
) ENGINE=MRG_MyISAM UNION=(t1);

EXPLAIN SELECT * FROM t2 IGNORE INDEX (files) WHERE fileset_id = 2
AND file_code BETWEEN '0000000115' AND '0000000120' LIMIT 1;
EXPLAIN SELECT * FROM t2 WHERE fileset_id = 2
AND file_code BETWEEN '0000000115' AND '0000000120' LIMIT 1;
EXPLAIN SELECT * FROM t1 WHERE fileset_id = 2
AND file_code BETWEEN '0000000115' AND '0000000120' LIMIT 1;
EXPLAIN SELECT * FROM t2 WHERE fileset_id = 2
AND file_code = '0000000115' LIMIT 1;
DROP TABLE t2, t1;

#
# Test of ORDER BY DESC on key (Bug #515)
#

create table t1 (x int, y int, index xy(x, y));
create table t2 (x int, y int, index xy(x, y));
create table t3 (x int, y int, index xy(x, y)) engine=merge union=(t1,t2);
insert into t1 values(1, 2);
insert into t2 values(1, 3);
select * from t3 where x = 1 and y < 5 order by y;
# Bug is that followng query returns empty set while it must be same as above
select * from t3 where x = 1 and y < 5 order by y desc;
drop table t1,t2,t3;

#
# Bug#5232: CREATE TABLE ... SELECT
#

create table t1 (a int);
create table t2 (a int);
insert into t1 values (0);
insert into t2 values (1);
--error ER_WRONG_OBJECT
create table t3 engine=merge union=(t1, t2) select * from t1;
--error ER_WRONG_OBJECT
create table t3 engine=merge union=(t1, t2) select * from t2;
--error ER_WRONG_OBJECT
create table t3 engine=merge union=(t1, t2) select (select max(a) from t2);
drop table t1, t2;

#
# Bug#9112 - Merge table with composite index producing invalid results with some queries
# This test case will fail only without the bugfix and some
# non-deterministic circumstances. It depends on properly initialized
# "un-initialized" memory. At the time it happens with a standard
# non-debug build. But there is no guarantee that this will be always so.
#
create table t1 (
 a double(14,4),
 b varchar(10),
 index (a,b)
) engine=merge union=(t2,t3);

create table t2 (
 a double(14,4),
 b varchar(10),
 index (a,b)
) engine=myisam;

create table t3 (
 a double(14,4),
 b varchar(10),
 index (a,b)
) engine=myisam;

insert into t2 values ( null, '');
insert into t2 values ( 9999999999.999, '');
insert into t3 select * from t2;
select min(a), max(a) from t1;
flush tables;
select min(a), max(a) from t1;
drop table t1, t2, t3;
# BUG#6699 : no sorting on 'ref' retrieval 
create table t1 (a int,b int,c int, index (a,b,c));
create table t2 (a int,b int,c int, index (a,b,c));
create table t3 (a int,b int,c int, index (a,b,c))
  engine=merge union=(t1 ,t2);
insert into t1 (a,b,c) values (1,1,0),(1,2,0);
insert into t2 (a,b,c) values (1,1,1),(1,2,1);

explain select a,b,c from t3 force index (a) where a=1 order by a,b,c;
select a,b,c from t3 force index (a) where a=1 order by a,b,c;

# this actually wasn't affected:
explain select a,b,c from t3 force index (a) where a=1 order by a desc, b desc, c desc;
select a,b,c from t3 force index (a) where a=1 order by a desc, b desc, c desc;

# BUG#7377 SHOW index on MERGE table crashes debug server
show index from t3;

drop table t1, t2, t3;

#
# Bug#10400 - Improperly-defined MERGE table crashes with INSERT ... ON DUPLICATE KEY UPDATE
#
CREATE TABLE t1 ( a INT AUTO_INCREMENT PRIMARY KEY, b VARCHAR(10), UNIQUE (b) )
  ENGINE=MyISAM;
CREATE TABLE t2 ( a INT AUTO_INCREMENT, b VARCHAR(10), INDEX (a), INDEX (b) )
  ENGINE=MERGE UNION (t1) INSERT_METHOD=FIRST;
INSERT INTO t2 (b) VALUES (1) ON DUPLICATE KEY UPDATE b=2;
INSERT INTO t2 (b) VALUES (1) ON DUPLICATE KEY UPDATE b=3;
SELECT b FROM t2;
DROP TABLE t1, t2;


#
# BUG#5390 - problems with merge tables
# Problem #1: INSERT...SELECT
#
#drop table if exists t1, t2, t3;
create table t1(a int);
create table t2(a int);
insert into t1 values (1);
insert into t2 values (2);
create table t3 (a int) engine=merge union=(t1, t2) insert_method=first;
select * from t3;
#
insert t2 select * from t2;
select * from t2;
#
insert t3 select * from t1;
select * from t3;
#
insert t1 select * from t3;
select * from t1;
select * from t2;
select * from t3;
check table t1, t2;
drop table t1, t2, t3;

#
# BUG#21617 - crash when selecting from merge table with inconsistent
# indexes
#
CREATE TABLE t1(a INT);
INSERT INTO t1 VALUES(2),(1);
CREATE TABLE t2(a INT, KEY(a)) ENGINE=MERGE UNION=(t1);
--error 1168
SELECT * FROM t2 WHERE a=2;
DROP TABLE t1, t2;

#
# BUG#10974 - No error message if merge table based on union of innodb,
# memory
#
CREATE TABLE t1(a INT) ENGINE=MEMORY;
CREATE TABLE t2(a INT) ENGINE=MERGE UNION=(t1);
--error 1168
SELECT * FROM t2;
DROP TABLE t1, t2;
CREATE TABLE t2(a INT) ENGINE=MERGE UNION=(t3);
--error ER_NO_SUCH_TABLE
SELECT * FROM t2;
DROP TABLE t2;

#
# Underlying table definition conformance tests.
#
CREATE TABLE t1(a INT, b TEXT);
CREATE TABLE tm1(a TEXT, b INT) ENGINE=MERGE UNION=(t1);
--error 1168
SELECT * FROM tm1;
DROP TABLE t1, tm1;

CREATE TABLE t1(a SMALLINT, b SMALLINT);
CREATE TABLE tm1(a INT) ENGINE=MERGE UNION=(t1);
--error 1168
SELECT * FROM tm1;
DROP TABLE t1, tm1;

CREATE TABLE t1(a SMALLINT, b SMALLINT, KEY(a, b));
CREATE TABLE tm1(a SMALLINT, b SMALLINT, KEY(a)) ENGINE=MERGE UNION=(t1);
--error 1168
SELECT * FROM tm1;
DROP TABLE t1, tm1;

CREATE TABLE t1(a SMALLINT, b SMALLINT, KEY(b));
CREATE TABLE tm1(a SMALLINT, b SMALLINT, KEY(a)) ENGINE=MERGE UNION=(t1);
--error 1168
SELECT * FROM tm1;
DROP TABLE t1, tm1;


# BUG#26881 - Large MERGE tables report incorrect specification when no
#             differences in tables
#
CREATE TABLE t1(c1 VARCHAR(1));
CREATE TABLE m1 LIKE t1;
ALTER TABLE m1 ENGINE=MERGE UNION=(t1);
SELECT * FROM m1;
DROP TABLE t1, m1;

CREATE TABLE t1(c1 VARCHAR(4), c2 TINYINT, c3 TINYINT, c4 TINYINT,
                c5 TINYINT, c6 TINYINT, c7 TINYINT, c8 TINYINT, c9 TINYINT);
CREATE TABLE m1 LIKE t1;
ALTER TABLE m1 ENGINE=MERGE UNION=(t1);
SELECT * FROM m1;
DROP TABLE t1, m1;

#
# BUG#24342 - Incorrect results with query over MERGE table
#
CREATE TABLE t1 (a VARCHAR(255) CHARACTER SET latin1 COLLATE latin1_german2_ci,
                 b INT, INDEX(a,b));
CREATE TABLE t2 LIKE t1;
CREATE TABLE t3 LIKE t1;
ALTER TABLE t3 ENGINE=MERGE UNION=(t1,t2);
INSERT INTO t1 VALUES ('ss',1);
INSERT INTO t2 VALUES ('ss',2),(0xDF,2);
SELECT COUNT(*) FROM t3 WHERE a=0xDF AND b=2;
DROP TABLE t1,t2,t3;

# End of 4.1 tests

#
# BUG#19648 - Merge table does not work with bit types
#
create table t1 (b bit(1));
create table t2 (b bit(1));
create table tm (b bit(1)) engine = merge union = (t1,t2);
select * from tm;
drop table tm, t1, t2;

#
# Bug #17766: The server accepts to create MERGE tables which cannot work
#
create table t1 (a int) insert_method = last engine = merge;
--error ER_OPEN_AS_READONLY
insert into t1 values (1);
create table t2 (a int) engine = myisam;
alter table t1 union (t2);
insert into t1 values (1);
alter table t1 insert_method = no;
--error ER_OPEN_AS_READONLY
insert into t1 values (1);
drop table t2;
drop table t1;

#
# BUG#26976 - Missing table in merge not noted in related error msg + SHOW
#             CREATE TABLE fails
#
CREATE TABLE tm1(a INT) ENGINE=MERGE UNION=(t1, t2);
--error ER_NO_SUCH_TABLE
SELECT * FROM tm1;
CHECK TABLE tm1;
CREATE TABLE t1(a INT);
--error ER_NO_SUCH_TABLE
SELECT * FROM tm1;
CHECK TABLE tm1;
CREATE TABLE t2(a BLOB);
--error ER_WRONG_MRG_TABLE
SELECT * FROM tm1;
CHECK TABLE tm1;
ALTER TABLE t2 MODIFY a INT;
SELECT * FROM tm1;
CHECK TABLE tm1;
DROP TABLE tm1, t1, t2;

#
# Bug#15522 - create ... select and with merge tables
#
# This was fixed together with Bug#20662 (Infinite loop in CREATE TABLE
# IF NOT EXISTS ... SELECT with locked tables).
# The new behavior for MERGE tables is consistent with the
# CREATE TABLE SELECT behavior for ordinary tables.
#
CREATE TABLE t1(c1 INT);
CREATE TABLE t2 (c1 INT) ENGINE=MERGE UNION=(t1) INSERT_METHOD=FIRST;
--error ER_UPDATE_TABLE_USED
CREATE TABLE IF NOT EXISTS t1 SELECT * FROM t2;
DROP TABLE t1, t2;

#
# Bug #28837: MyISAM storage engine error (134) doing delete with self-join
#

CREATE TABLE t1 (id INT NOT NULL, ref INT NOT NULL, INDEX (id)) ENGINE=MyISAM;
CREATE TABLE t2 LIKE t1;

INSERT INTO t2 (id, ref) VALUES (1,3), (2,1), (3,2), (4,5), (4,4);
INSERT INTO t1 SELECT * FROM t2;
INSERT INTO t1 SELECT * FROM t2;

CREATE TABLE t3 (id INT NOT NULL, ref INT NOT NULL, INDEX (id)) ENGINE=MERGE
                                                                UNION(t1);

SELECT * FROM t3 AS a INNER JOIN t3 AS b USING (id) WHERE a.ref < b.ref;
SELECT * FROM t3;
DELETE FROM a USING t3 AS a INNER JOIN t3 AS b USING (id) WHERE a.ref < b.ref;
SELECT * FROM t3;

DROP TABLE t1, t2, t3;

#
# BUG#28248 - mysqldump results with MERGE ... UNION=() cannot be executed
#
CREATE TABLE t1(a INT);
CREATE TABLE m1(a INT) ENGINE=MERGE;
SHOW CREATE TABLE m1;
DROP TABLE m1;
CREATE TABLE m1(a INT) ENGINE=MERGE UNION=();
SHOW CREATE TABLE m1;
ALTER TABLE m1 UNION=(t1);
ALTER TABLE m1 UNION=();
SHOW CREATE TABLE m1;
DROP TABLE t1, m1;

#
# BUG#35274 - merge table doesn't need any base tables, gives error 124 when
#             key accessed
#
CREATE TABLE t1(a INT, KEY(a)) ENGINE=merge;
SELECT MAX(a) FROM t1;
DROP TABLE t1;

--echo End of 5.0 tests

#
# Bug #8306: TRUNCATE leads to index corruption 
#
create table t1 (c1 int, index(c1));
create table t2 (c1 int, index(c1)) engine=merge union=(t1);
insert into t1 values (1);
# Close all tables.
flush tables;
# Open t2 and (implicitly) t1.
select * from t2;
# Truncate after flush works (unless another threads reopens t2 in between).
flush tables;
truncate table t1;
insert into t1 values (1);
# Close all tables.
flush tables;
# Open t2 and (implicitly) t1.
select * from t2;
# Truncate t1, wich was not recognized as open without the bugfix.
# After fix for Bug#8306 and before fix for Bug#26379,
# it should fail with a table-in-use error message, otherwise succeed.
truncate table t1;
# The insert used to fail on the crashed table.
insert into t1 values (1);
drop table t1,t2;
--echo #
--echo # Extra tests for TRUNCATE.
--echo #
--echo # Truncate MERGE table.
CREATE TABLE t1 (c1 INT, INDEX(c1));
CREATE TABLE t2 (c1 INT, INDEX(c1));
CREATE TABLE t3 (c1 INT, INDEX(c1)) ENGINE=MRG_MYISAM UNION=(t1,t2);
INSERT INTO t1 VALUES (1);
INSERT INTO t2 VALUES (2);
SELECT * FROM t3;
TRUNCATE TABLE t3;
SELECT * FROM t3;
--echo #
--echo # Truncate child table.
INSERT INTO t1 VALUES (1);
INSERT INTO t2 VALUES (2);
TRUNCATE TABLE t1;
SELECT * FROM t3;
--echo #
--echo # Truncate MERGE table under locked tables.
LOCK TABLE t1 WRITE, t2 WRITE, t3 WRITE;
INSERT INTO t1 VALUES (1);
--error ER_LOCK_OR_ACTIVE_TRANSACTION
TRUNCATE TABLE t3;
SELECT * FROM t3;
--echo #
--echo # Truncate child table under locked tables.
--error ER_LOCK_OR_ACTIVE_TRANSACTION
TRUNCATE TABLE t1;
SELECT * FROM t3;
UNLOCK TABLES;
DROP TABLE t1, t2, t3;
--echo #
--echo # Truncate temporary MERGE table.
CREATE TEMPORARY TABLE t1 (c1 INT, INDEX(c1));
CREATE TEMPORARY TABLE t2 (c1 INT, INDEX(c1));
CREATE TEMPORARY TABLE t3 (c1 INT, INDEX(c1)) ENGINE=MRG_MYISAM UNION=(t1,t2);
INSERT INTO t1 VALUES (1);
INSERT INTO t2 VALUES (2);
SELECT * FROM t3;
TRUNCATE TABLE t3;
SELECT * FROM t3;
--echo #
--echo # Truncate temporary child table.
INSERT INTO t1 VALUES (1);
INSERT INTO t2 VALUES (2);
TRUNCATE TABLE t1;
SELECT * FROM t3;
--echo #
--echo # Truncate temporary MERGE table under locked tables.
INSERT INTO t1 VALUES (1);
CREATE TABLE t4 (c1 INT, INDEX(c1));
LOCK TABLE t4 WRITE;
--error ER_LOCK_OR_ACTIVE_TRANSACTION
TRUNCATE TABLE t3;
SELECT * FROM t3;
--echo #
--echo # Truncate temporary child table under locked tables.
--error ER_LOCK_OR_ACTIVE_TRANSACTION
TRUNCATE TABLE t1;
SELECT * FROM t3;
UNLOCK TABLES;
DROP TABLE t1, t2, t3, t4;

--echo #
--echo # Extra tests for Bug#26379 - Combination of FLUSH TABLE and
--echo #                             REPAIR TABLE corrupts a MERGE table
#
--echo #
--echo # CREATE ... SELECT is disabled for MERGE tables.
--echo #
CREATE TABLE t1(c1 INT);
INSERT INTO t1 VALUES (1);
CREATE TABLE t2 (c1 INT) ENGINE=MRG_MYISAM UNION=(t1) INSERT_METHOD=LAST;
--error ER_OPEN_AS_READONLY
CREATE TABLE t3 ENGINE=MRG_MYISAM INSERT_METHOD=LAST SELECT * FROM t2;
--error ER_NO_SUCH_TABLE
SHOW CREATE TABLE t3;
--error ER_WRONG_OBJECT
CREATE TABLE t3 ENGINE=MRG_MYISAM UNION=(t1) INSERT_METHOD=LAST
  SELECT * FROM t2;
--error ER_NO_SUCH_TABLE
SHOW CREATE TABLE t3;
DROP TABLE t1, t2;
#
--echo #
--echo # CREATE ... LIKE
--echo #
--echo # 1. Create like.
CREATE TABLE t1 (c1 INT);
CREATE TABLE t2 (c1 INT);
CREATE TABLE t3 (c1 INT) ENGINE=MRG_MYISAM UNION=(t1,t2)
  INSERT_METHOD=LAST;
INSERT INTO t1 VALUES (1);
INSERT INTO t2 VALUES (2);
INSERT INTO t3 VALUES (3);
CREATE TABLE t4 LIKE t3;
SHOW CREATE TABLE t4;
--error ER_OPEN_AS_READONLY
INSERT INTO t4 VALUES (4);
DROP TABLE t4;
--echo #
--echo # 1. Create like with locked tables.
LOCK TABLES t3 WRITE, t2 WRITE, t1 WRITE;
CREATE TABLE t4 LIKE t3;
--error ER_TABLE_NOT_LOCKED
SHOW CREATE TABLE t4;
--error ER_TABLE_NOT_LOCKED
INSERT INTO t4 VALUES (4);
UNLOCK TABLES;
SHOW CREATE TABLE t4;
--error ER_OPEN_AS_READONLY
INSERT INTO t4 VALUES (4);
DROP TABLE t4;
#
--echo #
--echo # Rename child.
--echo #
--echo # 1. Normal rename of non-MERGE table.
CREATE TABLE t4 (c1 INT);
INSERT INTO t4 VALUES (4);
SELECT * FROM t4 ORDER BY c1;
RENAME TABLE t4 TO t5;
SELECT * FROM t5 ORDER BY c1;
RENAME TABLE t5 TO t4;
SELECT * FROM t4 ORDER BY c1;
DROP TABLE t4;
--echo #
--echo # 2. Normal rename.
SELECT * FROM t3 ORDER BY c1;
RENAME TABLE t2 TO t5;
--error ER_NO_SUCH_TABLE
SELECT * FROM t3 ORDER BY c1;
RENAME TABLE t5 TO t2;
SELECT * FROM t3 ORDER BY c1;
--echo #
--echo # 3. Normal rename with locked tables.
LOCK TABLES t1 WRITE, t2 WRITE, t3 WRITE;
SELECT * FROM t3 ORDER BY c1;
--error ER_LOCK_OR_ACTIVE_TRANSACTION
RENAME TABLE t2 TO t5;
SELECT * FROM t3 ORDER BY c1;
--error ER_LOCK_OR_ACTIVE_TRANSACTION
RENAME TABLE t5 TO t2;
SELECT * FROM t3 ORDER BY c1;
UNLOCK TABLES;
--echo #
--echo # 4. Alter table rename.
ALTER TABLE t2 RENAME TO t5;
--error ER_NO_SUCH_TABLE
SELECT * FROM t3 ORDER BY c1;
ALTER TABLE t5 RENAME TO t2;
SELECT * FROM t3 ORDER BY c1;
--echo #
--echo # 5. Alter table rename with locked tables.
LOCK TABLES t1 WRITE, t2 WRITE, t3 WRITE;
ALTER TABLE t2 RENAME TO t5;
--error ER_TABLE_NOT_LOCKED
SELECT * FROM t3 ORDER BY c1;
--error ER_TABLE_NOT_LOCKED
ALTER TABLE t5 RENAME TO t2;
UNLOCK TABLES;
ALTER TABLE t5 RENAME TO t2;
SELECT * FROM t3 ORDER BY c1;
#
--echo #
--echo # Rename parent.
--echo #
--echo # 1. Normal rename with locked tables.
LOCK TABLES t1 WRITE, t2 WRITE, t3 WRITE;
SELECT * FROM t3 ORDER BY c1;
--error ER_LOCK_OR_ACTIVE_TRANSACTION
RENAME TABLE t3 TO t5;
SELECT * FROM t3 ORDER BY c1;
--error ER_LOCK_OR_ACTIVE_TRANSACTION
RENAME TABLE t5 TO t3;
SELECT * FROM t3 ORDER BY c1;
--echo #
--echo # 5. Alter table rename with locked tables.
ALTER TABLE t3 RENAME TO t5;
--error ER_TABLE_NOT_LOCKED
SELECT * FROM t5 ORDER BY c1;
--error ER_TABLE_NOT_LOCKED
ALTER TABLE t5 RENAME TO t3;
UNLOCK TABLES;
ALTER TABLE t5 RENAME TO t3;
SELECT * FROM t3 ORDER BY c1;
DROP TABLE t1, t2, t3;
#
--echo #
--echo # Drop locked tables.
--echo #
--echo # 1. Drop parent.
CREATE TABLE t1 (c1 INT, INDEX(c1));
CREATE TABLE t2 (c1 INT, INDEX(c1)) ENGINE=MRG_MYISAM UNION=(t1)
  INSERT_METHOD=LAST;
LOCK TABLES t1 WRITE, t2 WRITE;
INSERT INTO t1 VALUES (1);
DROP TABLE t2;
--error ER_TABLE_NOT_LOCKED
SELECT * FROM t2;
SELECT * FROM t1;
UNLOCK TABLES;
--echo # 2. Drop child.
CREATE TABLE t2 (c1 INT, INDEX(c1)) ENGINE=MRG_MYISAM UNION=(t1)
  INSERT_METHOD=LAST;
LOCK TABLES t1 WRITE, t2 WRITE;
INSERT INTO t1 VALUES (1);
DROP TABLE t1;
--error ER_TABLE_NOT_LOCKED
SELECT * FROM t2;
--error ER_TABLE_NOT_LOCKED
SELECT * FROM t1;
UNLOCK TABLES;
DROP TABLE t2;
#
--echo #
--echo # ALTER TABLE. Change child list.
--echo #
CREATE TABLE t1 (c1 INT, INDEX(c1));
CREATE TABLE t2 (c1 INT, INDEX(c1));
CREATE TABLE t3 (c1 INT, INDEX(c1));
INSERT INTO t1 VALUES (1);
INSERT INTO t2 VALUES (2);
INSERT INTO t3 VALUES (3);
CREATE TABLE t4 (c1 INT, INDEX(c1)) ENGINE=MRG_MYISAM UNION=(t3,t2)
  INSERT_METHOD=LAST;
--echo # Shrink child list.
ALTER TABLE t4 UNION=(t3);
SHOW CREATE TABLE t4;
SELECT * FROM t4 ORDER BY c1;
--echo # Extend child list.
ALTER TABLE t4 UNION=(t3,t2);
SHOW CREATE TABLE t4;
SELECT * FROM t4 ORDER BY c1;
#
--echo #
--echo # ALTER TABLE under LOCK TABLES. Change child list.
--echo #
LOCK TABLES t4 WRITE, t3 WRITE, t2 WRITE;
--echo # Shrink child list.
--error ER_LOCK_OR_ACTIVE_TRANSACTION
ALTER TABLE t4 UNION=(t3);
--echo # Extend child list within locked tables.
--error ER_LOCK_OR_ACTIVE_TRANSACTION
ALTER TABLE t4 UNION=(t3,t2);
--echo # Extend child list beyond locked tables.
--error ER_LOCK_OR_ACTIVE_TRANSACTION
ALTER TABLE t4 UNION=(t3,t2,t1);
SHOW CREATE TABLE t4;
SELECT * FROM t4 ORDER BY c1;
UNLOCK TABLES;
DROP TABLE t4;
#
--echo #
--echo # ALTER TABLE under LOCK TABLES. Grave change, table re-creation.
--echo #
CREATE TABLE t4 (c1 INT, INDEX(c1)) ENGINE=MRG_MYISAM UNION=(t1,t2,t3)
  INSERT_METHOD=LAST;
--echo # Lock parent first and then children.
LOCK TABLES t4 WRITE, t3 WRITE, t2 WRITE, t1 WRITE;
ALTER TABLE t4 DROP INDEX c1, ADD UNIQUE INDEX (c1);
SELECT * FROM t4 ORDER BY c1;
ALTER TABLE t2 DROP INDEX c1, ADD UNIQUE INDEX (c1);
SELECT * FROM t4 ORDER BY c1;
UNLOCK TABLES;
--echo # Lock children first and then parent.
LOCK TABLES t1 WRITE, t2 WRITE, t3 WRITE, t4 WRITE;
ALTER TABLE t4 DROP INDEX c1, ADD UNIQUE INDEX (c1);
SELECT * FROM t4 ORDER BY c1;
ALTER TABLE t2 DROP INDEX c1, ADD UNIQUE INDEX (c1);
SELECT * FROM t4 ORDER BY c1;
UNLOCK TABLES;
--echo # Lock parent between children.
LOCK TABLES t3 WRITE, t2 WRITE, t4 WRITE, t1 WRITE;
ALTER TABLE t4 DROP INDEX c1, ADD UNIQUE INDEX (c1);
SELECT * FROM t4 ORDER BY c1;
ALTER TABLE t2 DROP INDEX c1, ADD UNIQUE INDEX (c1);
SELECT * FROM t4 ORDER BY c1;
UNLOCK TABLES;
DROP TABLE t1, t2, t3, t4;
#
--echo #
--echo # ALTER TABLE under LOCK TABLES. Simple change, no re-creation.
--echo #
CREATE TABLE t1 (c1 INT);
CREATE TABLE t2 (c1 INT);
CREATE TABLE t3 (c1 INT);
CREATE TABLE t4 (c1 INT) ENGINE=MRG_MYISAM UNION=(t1,t2,t3)
  INSERT_METHOD=LAST;
INSERT INTO t1 VALUES (1);
INSERT INTO t2 VALUES (2);
INSERT INTO t3 VALUES (3);
--echo # Lock parent first and then children.
LOCK TABLES t4 WRITE, t3 WRITE, t2 WRITE, t1 WRITE;
ALTER TABLE t4 ALTER COLUMN c1 SET DEFAULT 44;
SELECT * FROM t4 ORDER BY c1;
ALTER TABLE t2 ALTER COLUMN c1 SET DEFAULT 22;
SELECT * FROM t4 ORDER BY c1;
UNLOCK TABLES;
--echo # Lock children first and then parent.
LOCK TABLES t1 WRITE, t2 WRITE, t3 WRITE, t4 WRITE;
ALTER TABLE t4 ALTER COLUMN c1 SET DEFAULT 44;
SELECT * FROM t4 ORDER BY c1;
ALTER TABLE t2 ALTER COLUMN c1 SET DEFAULT 22;
SELECT * FROM t4 ORDER BY c1;
UNLOCK TABLES;
--echo # Lock parent between children.
LOCK TABLES t3 WRITE, t2 WRITE, t4 WRITE, t1 WRITE;
ALTER TABLE t4 ALTER COLUMN c1 SET DEFAULT 44;
SELECT * FROM t4 ORDER BY c1;
ALTER TABLE t2 ALTER COLUMN c1 SET DEFAULT 22;
SELECT * FROM t4 ORDER BY c1;
UNLOCK TABLES;
#
--echo #
--echo # FLUSH TABLE under LOCK TABLES.
--echo #
--echo # Lock parent first and then children.
LOCK TABLES t4 WRITE, t3 WRITE, t2 WRITE, t1 WRITE;
FLUSH TABLE t4;
SELECT * FROM t4 ORDER BY c1;
FLUSH TABLE t2;
SELECT * FROM t4 ORDER BY c1;
FLUSH TABLES;
SELECT * FROM t4 ORDER BY c1;
UNLOCK TABLES;
--echo # Lock children first and then parent.
LOCK TABLES t1 WRITE, t2 WRITE, t3 WRITE, t4 WRITE;
FLUSH TABLE t4;
SELECT * FROM t4 ORDER BY c1;
FLUSH TABLE t2;
SELECT * FROM t4 ORDER BY c1;
FLUSH TABLES;
SELECT * FROM t4 ORDER BY c1;
UNLOCK TABLES;
--echo # Lock parent between children.
LOCK TABLES t3 WRITE, t2 WRITE, t4 WRITE, t1 WRITE;
FLUSH TABLE t4;
SELECT * FROM t4 ORDER BY c1;
FLUSH TABLE t2;
SELECT * FROM t4 ORDER BY c1;
FLUSH TABLES;
SELECT * FROM t4 ORDER BY c1;
UNLOCK TABLES;
#
--echo #
--echo # Triggers
--echo #
--echo # Trigger on parent
DELETE FROM t4 WHERE c1 = 4;
CREATE TRIGGER t4_ai AFTER INSERT ON t4 FOR EACH ROW SET @a=1;
SET @a=0;
INSERT INTO t4 VALUES (4);
SELECT @a;
SELECT * FROM t4 ORDER BY c1;
DROP TRIGGER t4_ai;
--echo # Trigger on parent under LOCK TABLES
LOCK TABLES t3 WRITE, t2 WRITE, t4 WRITE, t1 WRITE;
CREATE TRIGGER t4_ai AFTER INSERT ON t4 FOR EACH ROW SET @a=1;
SET @a=0;
INSERT INTO t4 VALUES (4);
SELECT @a;
SELECT * FROM t4 ORDER BY c1;
DROP TRIGGER t4_ai;
UNLOCK TABLES;
--echo #
--echo # Trigger on child
DELETE FROM t4 WHERE c1 = 4;
CREATE TRIGGER t3_ai AFTER INSERT ON t3 FOR EACH ROW SET @a=1;
SET @a=0;
INSERT INTO t4 VALUES (4);
SELECT @a;
INSERT INTO t3 VALUES (33);
SELECT @a;
SELECT * FROM t4 ORDER BY c1;
DROP TRIGGER t3_ai;
--echo # Trigger on child under LOCK TABLES
LOCK TABLES t3 WRITE, t2 WRITE, t4 WRITE, t1 WRITE;
CREATE TRIGGER t3_ai AFTER INSERT ON t3 FOR EACH ROW SET @a=1;
SET @a=0;
INSERT INTO t4 VALUES (4);
SELECT @a;
INSERT INTO t3 VALUES (33);
SELECT @a;
SELECT * FROM t4 ORDER BY c1;
DELETE FROM t4 WHERE c1 = 33;
DROP TRIGGER t3_ai;
UNLOCK TABLES;
--echo #
--echo # Trigger with table use on child
DELETE FROM t4 WHERE c1 = 4;
CREATE TRIGGER t3_ai AFTER INSERT ON t3 FOR EACH ROW INSERT INTO t2 VALUES(22);
INSERT INTO t4 VALUES (4);
SELECT * FROM t4 ORDER BY c1;
INSERT INTO t3 VALUES (33);
SELECT * FROM t4 ORDER BY c1;
DELETE FROM t4 WHERE c1 = 22;
DELETE FROM t4 WHERE c1 = 33;
DROP TRIGGER t3_ai;
--echo # Trigger with table use on child under LOCK TABLES
LOCK TABLES t3 WRITE, t2 WRITE, t4 WRITE, t1 WRITE;
CREATE TRIGGER t3_ai AFTER INSERT ON t3 FOR EACH ROW INSERT INTO t2 VALUES(22);
INSERT INTO t4 VALUES (4);
SELECT * FROM t4 ORDER BY c1;
INSERT INTO t3 VALUES (33);
SELECT * FROM t4 ORDER BY c1;
DROP TRIGGER t3_ai;
DELETE FROM t4 WHERE c1 = 22;
DELETE FROM t4 WHERE c1 = 33;
UNLOCK TABLES;
#
--echo #
--echo # Repair
--echo #
REPAIR TABLE t4;
REPAIR TABLE t2;
SELECT * FROM t4 ORDER BY c1;
LOCK TABLES t3 WRITE, t2 WRITE, t4 WRITE, t1 WRITE;
REPAIR TABLE t4;
REPAIR TABLE t2;
SELECT * FROM t4 ORDER BY c1;
UNLOCK TABLES;
#
--echo #
--echo # Optimize
--echo #
OPTIMIZE TABLE t4;
OPTIMIZE TABLE t2;
SELECT * FROM t4 ORDER BY c1;
LOCK TABLES t3 WRITE, t2 WRITE, t4 WRITE, t1 WRITE;
OPTIMIZE TABLE t4;
OPTIMIZE TABLE t2;
SELECT * FROM t4 ORDER BY c1;
UNLOCK TABLES;
#
--echo #
--echo # Checksum
--echo #
CHECKSUM TABLE t4;
CHECKSUM TABLE t2;
SELECT * FROM t4 ORDER BY c1;
LOCK TABLES t3 WRITE, t2 WRITE, t4 WRITE, t1 WRITE;
CHECKSUM TABLE t4;
CHECKSUM TABLE t2;
SELECT * FROM t4 ORDER BY c1;
UNLOCK TABLES;
#
--echo #
--echo # Insert delayed
--echo #
# See also Bug#26464 - insert delayed + update + merge = corruption
# Succeeds in embedded server - is converted to normal insert
# Fails in normal server, ps-protocol - not supported by engine
# Fails in normal server, normal protocol - not a base table
--error 0, ER_DELAYED_NOT_SUPPORTED, ER_WRONG_OBJECT
INSERT DELAYED INTO t4 VALUES(44);
# Get rid of row in embedded server
DELETE FROM t4 WHERE c1 = 44;
INSERT DELAYED INTO t3 VALUES(33);
  let $wait_cmd= SHOW STATUS LIKE 'Not_flushed_delayed_rows';
  let $run= query_get_value($wait_cmd, Value, 1);
  while ($run)
  {
    let $run= query_get_value($wait_cmd, Value, 1);
  }
SELECT * FROM t4 ORDER BY c1;
LOCK TABLES t3 WRITE, t2 WRITE, t4 WRITE, t1 WRITE;
--error ER_DELAYED_INSERT_TABLE_LOCKED, ER_DELAYED_NOT_SUPPORTED
INSERT DELAYED INTO t4 VALUES(444);
--error ER_DELAYED_INSERT_TABLE_LOCKED, ER_DELAYED_NOT_SUPPORTED
INSERT DELAYED INTO t3 VALUES(333);
SELECT * FROM t4 ORDER BY c1;
UNLOCK TABLES;
DROP TABLE t1, t2, t3, t4;
#
--echo #
--echo # Recursive inclusion of merge tables in their union clauses.
--echo #
CREATE TABLE t1 (c1 INT, INDEX(c1));
CREATE TABLE t2 (c1 INT, INDEX(c1)) ENGINE=MRG_MYISAM UNION=(t1)
  INSERT_METHOD=LAST;
CREATE TABLE t3 (c1 INT, INDEX(c1)) ENGINE=MRG_MYISAM UNION=(t2,t1)
  INSERT_METHOD=LAST;
ALTER TABLE t2 UNION=(t3,t1);
--error ER_ADMIN_WRONG_MRG_TABLE
SELECT * FROM t2;
DROP TABLE t1, t2, t3;


#
# Bug#25038 - Waiting TRUNCATE
# Truncate failed with error message when table was in use by MERGE.
#
# Show that truncate of child table after use of parent table works.
CREATE TABLE t1 (c1 INT) ENGINE=MyISAM; 
CREATE TABLE t2 (c1 INT) ENGINE=MyISAM; 
CREATE TABLE t3 (c1 INT) ENGINE=MRG_MYISAM UNION=(t1,t2); 
INSERT INTO t1 VALUES (1);
INSERT INTO t2 VALUES (2);
SELECT * FROM t3;
TRUNCATE TABLE t1;
SELECT * FROM t3;
DROP TABLE t1, t2, t3;

#
# Bug#25700 - merge base tables get corrupted by optimize/analyze/repair table
#
# Using FLUSH TABLES before REPAIR.
CREATE TABLE t1 (c1 INT) ENGINE=MyISAM;
CREATE TABLE t2 (c1 INT) ENGINE=MRG_MYISAM UNION=(t1) INSERT_METHOD=LAST;
INSERT INTO t2 VALUES (1);
SELECT * FROM t2;
LOCK TABLES t2 WRITE, t1 WRITE;
FLUSH TABLES;
REPAIR TABLE t1;
CHECK TABLE t1;
REPAIR TABLE t1;
UNLOCK TABLES;
CHECK TABLE t1 EXTENDED;
#
# Not using FLUSH TABLES before REPAIR.
LOCK TABLES t2 WRITE, t1 WRITE;
REPAIR TABLE t1;
CHECK TABLE t1;
REPAIR TABLE t1;
UNLOCK TABLES;
CHECK TABLE t1 EXTENDED;
DROP TABLE t1, t2;

#
# Bug#26377 - Deadlock with MERGE and FLUSH TABLE
#
CREATE TABLE t1 ( a INT ) ENGINE=MyISAM;
CREATE TABLE m1 ( a INT ) ENGINE=MRG_MYISAM UNION=(t1);
# Lock t1 first. This did always work.
LOCK TABLES t1 WRITE, m1 WRITE;
FLUSH TABLE t1;
UNLOCK TABLES;
DROP TABLE m1, t1;
#
CREATE TABLE t1 ( a INT ) ENGINE=MyISAM;
CREATE TABLE m1 ( a INT ) ENGINE=MRG_MYISAM UNION=(t1);
# Lock m1 first. This did deadlock.
LOCK TABLES m1 WRITE, t1 WRITE;
FLUSH TABLE t1;
UNLOCK TABLES;
DROP TABLE m1, t1;

#
# Bug#27660 - Falcon: merge table possible
#
# Normal MyISAM MERGE operation.
CREATE TABLE t1 (c1 INT, c2 INT) ENGINE= MyISAM;
CREATE TABLE t2 (c1 INT, c2 INT) ENGINE= MyISAM;
CREATE TABLE t3 (c1 INT, c2 INT) ENGINE= MRG_MYISAM UNION(t1, t2);
INSERT INTO t1 VALUES (1, 1);
INSERT INTO t2 VALUES (2, 2);
SELECT * FROM t3;
# Try an unsupported engine.
ALTER TABLE t1 ENGINE= MEMORY;
INSERT INTO t1 VALUES (0, 0);
# Before fixing, this succeeded, but (0, 0) was missing.
--error 1168
SELECT * FROM t3;
DROP TABLE t1, t2, t3;

#
# Bug#30275 - Merge tables: flush tables or unlock tables causes server to crash
#
CREATE TABLE t1 (c1 INT, KEY(c1));
CREATE TABLE t2 (c1 INT, KEY(c1)) ENGINE=MRG_MYISAM UNION=(t1)
  INSERT_METHOD=FIRST;
LOCK TABLE t1 WRITE, t2 WRITE;
FLUSH TABLES t2, t1;
OPTIMIZE TABLE t1;
FLUSH TABLES t1;
UNLOCK TABLES;
#
FLUSH TABLES;
INSERT INTO t1 VALUES (1);
LOCK TABLE t1 WRITE, t2 WRITE;
FLUSH TABLES t2, t1;
OPTIMIZE TABLE t1;
FLUSH TABLES t1;
UNLOCK TABLES;
DROP TABLE t1, t2;

#
# Test derived from test program for
# Bug#30273 - merge tables: Can't lock file (errno: 155)
#
CREATE TABLE t1 (ID INT) ENGINE=MYISAM;
CREATE TABLE m1 (ID INT) ENGINE=MRG_MYISAM UNION=(t1) INSERT_METHOD=FIRST;
INSERT INTO t1 VALUES ();
INSERT INTO m1 VALUES ();
LOCK TABLE t1 WRITE, m1 WRITE;
FLUSH TABLES m1, t1;
OPTIMIZE TABLE t1;
FLUSH TABLES m1, t1;
UNLOCK TABLES;
DROP TABLE t1, m1;


#
# Bug#36006 - Optimizer does table scan for select count(*)
#
CREATE TABLE t1(C1 INT, C2 INT, KEY C1(C1), KEY C2(C2)) ENGINE=MYISAM;
CREATE TABLE t2(C1 INT, C2 INT, KEY C1(C1), KEY C2(C2)) ENGINE=MYISAM;
CREATE TABLE t3(C1 INT, C2 INT, KEY C1(C1), KEY C2(C2)) ENGINE=MYISAM;
CREATE TABLE t4(C1 INT, C2 INT, KEY C1(C1), KEY C2(C2))
  ENGINE=MRG_MYISAM UNION=(t1, t2, t3);
INSERT INTO t1 VALUES (1,1), (1,2),(1,3), (1,4);
INSERT INTO t2 VALUES (2,1), (2,2),(2,3), (2,4);
INSERT INTO t3 VALUES (3,1), (3,2),(3,3), (3,4);
EXPLAIN SELECT COUNT(*) FROM t1;
EXPLAIN SELECT COUNT(*) FROM t4;
DROP TABLE t1, t2, t3, t4;

--echo End of 5.1 tests


--echo #
--echo # An additional test case for Bug#27430 Crash in subquery code
--echo # when in PS and table DDL changed after PREPARE
--echo #
--echo # Test merge table with too many merge children.
--echo #
--disable_warnings
drop table if exists t_parent;
--enable_warnings
set @save_table_definition_cache=@@global.table_definition_cache;
--echo #
--echo # Set @@global.table_definition_cache to minimum
--echo #
set @@global.table_definition_cache=256;
set @a=null;
let $1 = 256;
--echo #
--echo # Create 256 merge children
--echo #
--disable_query_log
while ($1)
{
--disable_warnings
  eval drop table if exists t$1;
--enable_warnings
  eval create table t$1 (a int) engine=myisam;
  eval set @a=ifnull(concat(@a, ", ", "t$1"), "t$1");
  dec $1;
}
--enable_query_log
set @a=concat("create table t_parent (a int) union(", @a,
              ") insert_method=first engine=mrg_myisam");
prepare stmt from @a;
execute stmt;
prepare stmt from "select * from t_parent";
--error ER_NEED_REPREPARE
execute stmt;
--error ER_NEED_REPREPARE
execute stmt;
--error ER_NEED_REPREPARE
execute stmt;
deallocate prepare stmt;
--echo #
--echo # Create merge parent 
--echo #

--echo #
--echo # Cleanup
--echo #
let $1 = 256;
--disable_query_log
while ($1)
{
  eval drop table t$1;
  dec $1;
}
--enable_query_log
drop table t_parent;
set @@global.table_definition_cache=@save_table_definition_cache;

#
# WL#4144 - Lock MERGE engine children
#
# Test DATA/INDEX DIRECTORY
#
--disable_warnings
DROP DATABASE IF EXISTS mysql_test1;
--enable_warnings
CREATE DATABASE mysql_test1;
--disable_query_log
# data/index directory don't work in HAVE_purify builds. Disable
# build-dependent warnings.
--disable_warnings
--echo CREATE TABLE t1 ... DATA DIRECTORY=... INDEX DIRECTORY=...
eval CREATE TABLE t1 (c1 INT)
  DATA DIRECTORY='$MYSQLTEST_VARDIR/tmp'
  INDEX DIRECTORY='$MYSQLTEST_VARDIR/tmp';
--echo CREATE TABLE mysql_test1.t2 ... DATA DIRECTORY=... INDEX DIRECTORY=...
eval CREATE TABLE mysql_test1.t2 (c1 INT)
  DATA DIRECTORY='$MYSQLTEST_VARDIR/tmp'
  INDEX DIRECTORY='$MYSQLTEST_VARDIR/tmp';
--enable_query_log
--enable_warnings
CREATE TABLE m1 (c1 INT) ENGINE=MRG_MYISAM UNION=(t1,mysql_test1.t2)
  INSERT_METHOD=LAST;
INSERT INTO t1 VALUES (1);
INSERT INTO mysql_test1.t2 VALUES (2);
SELECT * FROM m1;
#--copy_file $MYSQLTEST_VARDIR/master-data/test/m1.MRG /tmp/mysql-test-m1.MRG
DROP TABLE t1, mysql_test1.t2, m1;
DROP DATABASE mysql_test1;
#
# Review detected Crash #1. Detaching main tables while in sub statement.
#
CREATE TABLE t1 (c1 INT);
CREATE TABLE t2 (c1 INT);
INSERT INTO t1 (c1) VALUES (1);
CREATE TABLE tm1 (c1 INT) ENGINE=MRG_MYISAM UNION=(t1,t2) INSERT_METHOD=FIRST;
CREATE TABLE t3 (c1 INT);
INSERT INTO t3 (c1) VALUES (1);
CREATE FUNCTION f1() RETURNS INT RETURN (SELECT MAX(c1) FROM t3);
CREATE VIEW v1 AS SELECT foo.c1 c1, f1() c2, bar.c1 c3, f1() c4
                    FROM tm1 foo, tm1 bar, t3;
SELECT * FROM v1;
DROP FUNCTION f1;
DROP VIEW v1;
DROP TABLE tm1, t1, t2, t3;
#
# Review detected Crash #2. Trying to attach temporary table twice.
#
CREATE TEMPORARY TABLE t1 (c1 INT);
CREATE TEMPORARY TABLE t2 (c1 INT);
CREATE TEMPORARY TABLE tm1 (c1 INT) ENGINE=MRG_MYISAM UNION=(t1,t2)
  INSERT_METHOD=FIRST;
CREATE FUNCTION f1() RETURNS INT RETURN (SELECT MAX(c1) FROM tm1);
INSERT INTO tm1 (c1) VALUES (1);
SELECT f1() FROM (SELECT 1) AS c1;
DROP FUNCTION f1;
DROP TABLE tm1, t1, t2;
#
# Review suggested test. DDL in a stored function.
#
DELIMITER |;
CREATE FUNCTION f1() RETURNS INT
BEGIN
  CREATE TEMPORARY TABLE t1 (c1 INT);
  CREATE TEMPORARY TABLE t2 (c1 INT);
  CREATE TEMPORARY TABLE tm1 (c1 INT) ENGINE=MRG_MYISAM UNION=(t1,t2);
  INSERT INTO t1 (c1) VALUES (1);
  RETURN (SELECT MAX(c1) FROM tm1);
END|
DELIMITER ;|
SELECT f1() FROM (SELECT 1 UNION SELECT 1) c1;
DROP FUNCTION f1;
DROP TABLE tm1, t1, t2;
#
CREATE TEMPORARY TABLE t1 (c1 INT);
INSERT INTO t1 (c1) VALUES (1);
CREATE TEMPORARY TABLE tm1 (c1 INT) ENGINE=MRG_MYISAM UNION=(t1);
DELIMITER |;
--error ER_SP_BADSTATEMENT
CREATE FUNCTION f1() RETURNS INT
BEGIN
  CREATE TEMPORARY TABLE t2 (c1 INT);
  ALTER TEMPORARY TABLE tm1 UNION=(t1,t2);
  INSERT INTO t2 (c1) VALUES (2);
  RETURN (SELECT MAX(c1) FROM tm1);
END|
DELIMITER ;|
DROP TABLE tm1, t1;
#
# Base table. No LOCK TABLES, no functions/triggers.
#
CREATE TABLE t1 (c1 INT) ENGINE=MyISAM;
CREATE TABLE tm1 (c1 INT) ENGINE=MRG_MYISAM UNION=(t1) INSERT_METHOD=LAST;
INSERT INTO tm1 VALUES (1);
SELECT * FROM tm1;
DROP TABLE tm1, t1;
#
# Base table. No LOCK TABLES, sub-statement that is run inside a function.
#
DELIMITER |;
CREATE FUNCTION f1() RETURNS INT
BEGIN
  INSERT INTO tm1 VALUES (1);
  RETURN (SELECT MAX(c1) FROM tm1);
END|
DELIMITER ;|
CREATE TABLE t1 (c1 INT) ENGINE=MyISAM;
CREATE TABLE tm1 (c1 INT) ENGINE=MRG_MYISAM UNION=(t1) INSERT_METHOD=LAST;
SELECT f1();
DROP FUNCTION f1;
DROP TABLE tm1, t1;
#
# Base table. LOCK TABLES, no functions/triggers.
#
CREATE TABLE t1 (c1 INT) ENGINE=MyISAM;
CREATE TABLE tm1 (c1 INT) ENGINE=MRG_MYISAM UNION=(t1) INSERT_METHOD=LAST;
LOCK TABLE tm1 WRITE;
INSERT INTO tm1 VALUES (1);
SELECT * FROM tm1;
UNLOCK TABLES;
DROP TABLE tm1, t1;
#
# Base table. LOCK TABLES, sub-statement that is run inside a function.
#
DELIMITER |;
CREATE FUNCTION f1() RETURNS INT
BEGIN
  INSERT INTO tm1 VALUES (1);
  RETURN (SELECT MAX(c1) FROM tm1);
END|
DELIMITER ;|
CREATE TABLE t1 (c1 INT) ENGINE=MyISAM;
CREATE TABLE tm1 (c1 INT) ENGINE=MRG_MYISAM UNION=(t1) INSERT_METHOD=LAST;
LOCK TABLE tm1 WRITE;
SELECT f1();
UNLOCK TABLES;
DROP FUNCTION f1;
DROP TABLE tm1, t1;
#
# Base table. LOCK TABLES statement that locks a table that has a trigger
# that inserts into a merge table, so an attempt is made to lock tables
# of a sub-statement.
#
CREATE TABLE t1 (c1 INT) ENGINE=MyISAM;
CREATE TABLE t2 (c1 INT) ENGINE=MyISAM;
CREATE TABLE tm1 (c1 INT) ENGINE=MRG_MYISAM UNION=(t1) INSERT_METHOD=LAST;
CREATE TRIGGER t2_ai AFTER INSERT ON t2
  FOR EACH ROW INSERT INTO tm1 VALUES(11);
LOCK TABLE t2 WRITE;
INSERT INTO t2 VALUES (2);
SELECT * FROM tm1;
SELECT * FROM t2;
UNLOCK TABLES;
DROP TRIGGER t2_ai;
DROP TABLE tm1, t1, t2;
#
# Temporary. No LOCK TABLES, no functions/triggers.
#
CREATE TEMPORARY TABLE t1 (c1 INT) ENGINE=MyISAM;
CREATE TEMPORARY TABLE tm1 (c1 INT) ENGINE=MRG_MYISAM UNION=(t1)
  INSERT_METHOD=LAST;
INSERT INTO tm1 VALUES (1);
SELECT * FROM tm1;
DROP TABLE tm1, t1;
#
# Temporary. No LOCK TABLES, sub-statement that is run inside a function.
#
DELIMITER |;
CREATE FUNCTION f1() RETURNS INT
BEGIN
  INSERT INTO tm1 VALUES (1);
  RETURN (SELECT MAX(c1) FROM tm1);
END|
DELIMITER ;|
CREATE TEMPORARY TABLE t1 (c1 INT) ENGINE=MyISAM;
CREATE TEMPORARY TABLE tm1 (c1 INT) ENGINE=MRG_MYISAM UNION=(t1)
  INSERT_METHOD=LAST;
SELECT f1();
DROP FUNCTION f1;
DROP TABLE tm1, t1;
#
# Temporary. LOCK TABLES, no functions/triggers.
#
CREATE TEMPORARY TABLE t1 (c1 INT) ENGINE=MyISAM;
CREATE TEMPORARY TABLE tm1 (c1 INT) ENGINE=MRG_MYISAM UNION=(t1)
  INSERT_METHOD=LAST;
CREATE TABLE t9 (c1 INT) ENGINE=MyISAM;
LOCK TABLE t9 WRITE;
INSERT INTO tm1 VALUES (1);
SELECT * FROM tm1;
UNLOCK TABLES;
DROP TABLE tm1, t1, t9;
#
# Temporary. LOCK TABLES, sub-statement that is run inside a function.
#
DELIMITER |;
CREATE FUNCTION f1() RETURNS INT
BEGIN
  INSERT INTO tm1 VALUES (1);
  RETURN (SELECT MAX(c1) FROM tm1);
END|
DELIMITER ;|
CREATE TEMPORARY TABLE t1 (c1 INT) ENGINE=MyISAM;
CREATE TEMPORARY TABLE tm1 (c1 INT) ENGINE=MRG_MYISAM UNION=(t1)
  INSERT_METHOD=LAST;
CREATE TABLE t9 (c1 INT) ENGINE=MyISAM;
LOCK TABLE t9 WRITE;
SELECT f1();
UNLOCK TABLES;
DROP FUNCTION f1;
DROP TABLE tm1, t1, t9;
#
# Temporary. LOCK TABLES statement that locks a table that has a trigger
# that inserts into a merge table, so an attempt is made to lock tables
# of a sub-statement.
#
CREATE TEMPORARY TABLE t1 (c1 INT) ENGINE=MyISAM;
CREATE TEMPORARY TABLE tm1 (c1 INT) ENGINE=MRG_MYISAM UNION=(t1)
  INSERT_METHOD=LAST;
CREATE TABLE t2 (c1 INT) ENGINE=MyISAM;
CREATE TRIGGER t2_ai AFTER INSERT ON t2
  FOR EACH ROW INSERT INTO tm1 VALUES(11);
LOCK TABLE t2 WRITE;
INSERT INTO t2 VALUES (2);
SELECT * FROM tm1;
SELECT * FROM t2;
UNLOCK TABLES;
DROP TRIGGER t2_ai;
DROP TABLE tm1, t1, t2;
--echo #
--echo # Don't select MERGE child when trying to get prelocked table.
--echo #
CREATE TABLE t1 (c1 INT) ENGINE=MyISAM;
CREATE TABLE tm1 (c1 INT) ENGINE=MRG_MYISAM UNION=(t1)
  INSERT_METHOD=LAST;
CREATE TRIGGER tm1_ai AFTER INSERT ON tm1
  FOR EACH ROW INSERT INTO t1 VALUES(11);
LOCK TABLE tm1 WRITE, t1 WRITE;
INSERT INTO tm1 VALUES (1);
SELECT * FROM tm1;
UNLOCK TABLES;
LOCK TABLE t1 WRITE, tm1 WRITE;
INSERT INTO tm1 VALUES (1);
SELECT * FROM tm1;
UNLOCK TABLES;
DROP TRIGGER tm1_ai;
DROP TABLE tm1, t1;

# Don't resurrect chopped off prelocked tables.
# The problem is not visible by test results; only by debugging.
#
CREATE TABLE t1 (c1 INT) ENGINE=MyISAM;
CREATE TABLE t2 (c1 INT) ENGINE=MyISAM;
CREATE TABLE t3 (c1 INT) ENGINE=MyISAM;
CREATE TABLE t4 (c1 INT) ENGINE=MyISAM;
CREATE TABLE t5 (c1 INT) ENGINE=MyISAM;
CREATE TABLE tm1 (c1 INT) ENGINE=MRG_MYISAM UNION=(t1,t2,t3,t4,t5)
  INSERT_METHOD=LAST;
CREATE TRIGGER t2_au AFTER UPDATE ON t2
  FOR EACH ROW INSERT INTO t3 VALUES(33);
CREATE FUNCTION f1() RETURNS INT
  RETURN (SELECT MAX(c1) FROM t4);
LOCK TABLE tm1 WRITE, t1 WRITE, t2 WRITE, t3 WRITE, t4 WRITE, t5 WRITE;
INSERT INTO t1 VALUES(1);
INSERT INTO t2 VALUES(2);
INSERT INTO t3 VALUES(3);
INSERT INTO t4 VALUES(4);
INSERT INTO t5 VALUES(5);
    connect (con1,localhost,root,,);
    send UPDATE t2, tm1 SET t2.c1=f1();
connection default;
# Force reopen in other thread.
#sleep 1;
FLUSH TABLES;
#sleep 1;
FLUSH TABLES;
#sleep 1;
UNLOCK TABLES;
    connection con1;
    reap;
    disconnect con1;
connection default;
SELECT * FROM tm1;
DROP TRIGGER t2_au;
DROP FUNCTION f1;
DROP TABLE tm1, t1, t2, t3, t4, t5;



--echo End of 6.0 tests

--disable_result_log
--disable_query_log
eval set global storage_engine=$default;
--enable_result_log
--enable_query_log
